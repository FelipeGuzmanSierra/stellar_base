defmodule StellarBase.XDR.LedgerHeader do
  @moduledoc """
  Automatically generated by xdrgen
  DO NOT EDIT or your changes may be overwritten

  Target implementation: elixir_xdr at https://hex.pm/packages/elixir_xdr

  Representation of Stellar `LedgerHeader` type.
  """

  @behaviour XDR.Declaration

  alias StellarBase.XDR.{
    Uint32,
    Hash,
    StellarValue,
    Int64,
    Uint64,
    HashFixedList,
    LedgerHeaderExt
  }

  @struct_spec XDR.Struct.new(
    ledger_version: Uint32,
    previous_ledger_hash: Hash,
    scp_value: StellarValue,
    tx_set_result_hash: Hash,
    bucket_list_hash: Hash,
    ledger_seq: Uint32,
    total_coins: Int64,
    fee_pool: Int64,
    inflation_seq: Uint32,
    id_pool: Uint64,
    base_fee: Uint32,
    base_reserve: Uint32,
    max_tx_set_size: Uint32,
    skip_list: HashFixedList,
    ext: LedgerHeaderExt
  )

  @type type_ledger_version :: Uint32.t()
  @type type_previous_ledger_hash :: Hash.t()
  @type type_scp_value :: StellarValue.t()
  @type type_tx_set_result_hash :: Hash.t()
  @type type_bucket_list_hash :: Hash.t()
  @type type_ledger_seq :: Uint32.t()
  @type type_total_coins :: Int64.t()
  @type type_fee_pool :: Int64.t()
  @type type_inflation_seq :: Uint32.t()
  @type type_id_pool :: Uint64.t()
  @type type_base_fee :: Uint32.t()
  @type type_base_reserve :: Uint32.t()
  @type type_max_tx_set_size :: Uint32.t()
  @type type_skip_list :: HashFixedList.t()
  @type type_ext :: LedgerHeaderExt.t()

  @type t :: %__MODULE__{ledger_version: type_ledger_version(), previous_ledger_hash: type_previous_ledger_hash(), scp_value: type_scp_value(), tx_set_result_hash: type_tx_set_result_hash(), bucket_list_hash: type_bucket_list_hash(), ledger_seq: type_ledger_seq(), total_coins: type_total_coins(), fee_pool: type_fee_pool(), inflation_seq: type_inflation_seq(), id_pool: type_id_pool(), base_fee: type_base_fee(), base_reserve: type_base_reserve(), max_tx_set_size: type_max_tx_set_size(), skip_list: type_skip_list(), ext: type_ext()}

  defstruct [:ledger_version, :previous_ledger_hash, :scp_value, :tx_set_result_hash, :bucket_list_hash, :ledger_seq, :total_coins, :fee_pool, :inflation_seq, :id_pool, :base_fee, :base_reserve, :max_tx_set_size, :skip_list, :ext]

  @spec new(ledger_version :: type_ledger_version(), previous_ledger_hash :: type_previous_ledger_hash(), scp_value :: type_scp_value(), tx_set_result_hash :: type_tx_set_result_hash(), bucket_list_hash :: type_bucket_list_hash(), ledger_seq :: type_ledger_seq(), total_coins :: type_total_coins(), fee_pool :: type_fee_pool(), inflation_seq :: type_inflation_seq(), id_pool :: type_id_pool(), base_fee :: type_base_fee(), base_reserve :: type_base_reserve(), max_tx_set_size :: type_max_tx_set_size(), skip_list :: type_skip_list(), ext :: type_ext()) :: t()
  def new(
    %Uint32{} = ledger_version,
    %Hash{} = previous_ledger_hash,
    %StellarValue{} = scp_value,
    %Hash{} = tx_set_result_hash,
    %Hash{} = bucket_list_hash,
    %Uint32{} = ledger_seq,
    %Int64{} = total_coins,
    %Int64{} = fee_pool,
    %Uint32{} = inflation_seq,
    %Uint64{} = id_pool,
    %Uint32{} = base_fee,
    %Uint32{} = base_reserve,
    %Uint32{} = max_tx_set_size,
    %HashFixedList{} = skip_list,
    %LedgerHeaderExt{} = ext
  ),
  do: %__MODULE__{ledger_version: ledger_version, previous_ledger_hash: previous_ledger_hash, scp_value: scp_value, tx_set_result_hash: tx_set_result_hash, bucket_list_hash: bucket_list_hash, ledger_seq: ledger_seq, total_coins: total_coins, fee_pool: fee_pool, inflation_seq: inflation_seq, id_pool: id_pool, base_fee: base_fee, base_reserve: base_reserve, max_tx_set_size: max_tx_set_size, skip_list: skip_list, ext: ext}

  @impl true
  def encode_xdr(%__MODULE__{ledger_version: ledger_version, previous_ledger_hash: previous_ledger_hash, scp_value: scp_value, tx_set_result_hash: tx_set_result_hash, bucket_list_hash: bucket_list_hash, ledger_seq: ledger_seq, total_coins: total_coins, fee_pool: fee_pool, inflation_seq: inflation_seq, id_pool: id_pool, base_fee: base_fee, base_reserve: base_reserve, max_tx_set_size: max_tx_set_size, skip_list: skip_list, ext: ext}) do
    [ledger_version: ledger_version, previous_ledger_hash: previous_ledger_hash, scp_value: scp_value, tx_set_result_hash: tx_set_result_hash, bucket_list_hash: bucket_list_hash, ledger_seq: ledger_seq, total_coins: total_coins, fee_pool: fee_pool, inflation_seq: inflation_seq, id_pool: id_pool, base_fee: base_fee, base_reserve: base_reserve, max_tx_set_size: max_tx_set_size, skip_list: skip_list, ext: ext]
    |> XDR.Struct.new()
    |> XDR.Struct.encode_xdr()
  end

  @impl true
  def encode_xdr!(%__MODULE__{ledger_version: ledger_version, previous_ledger_hash: previous_ledger_hash, scp_value: scp_value, tx_set_result_hash: tx_set_result_hash, bucket_list_hash: bucket_list_hash, ledger_seq: ledger_seq, total_coins: total_coins, fee_pool: fee_pool, inflation_seq: inflation_seq, id_pool: id_pool, base_fee: base_fee, base_reserve: base_reserve, max_tx_set_size: max_tx_set_size, skip_list: skip_list, ext: ext}) do
    [ledger_version: ledger_version, previous_ledger_hash: previous_ledger_hash, scp_value: scp_value, tx_set_result_hash: tx_set_result_hash, bucket_list_hash: bucket_list_hash, ledger_seq: ledger_seq, total_coins: total_coins, fee_pool: fee_pool, inflation_seq: inflation_seq, id_pool: id_pool, base_fee: base_fee, base_reserve: base_reserve, max_tx_set_size: max_tx_set_size, skip_list: skip_list, ext: ext]
    |> XDR.Struct.new()
    |> XDR.Struct.encode_xdr!()
  end

  @impl true
  def decode_xdr(bytes, struct \\ @struct_spec)

  def decode_xdr(bytes, struct) do
    case XDR.Struct.decode_xdr(bytes, struct) do
      {:ok, {%XDR.Struct{components: [ledger_version: ledger_version, previous_ledger_hash: previous_ledger_hash, scp_value: scp_value, tx_set_result_hash: tx_set_result_hash, bucket_list_hash: bucket_list_hash, ledger_seq: ledger_seq, total_coins: total_coins, fee_pool: fee_pool, inflation_seq: inflation_seq, id_pool: id_pool, base_fee: base_fee, base_reserve: base_reserve, max_tx_set_size: max_tx_set_size, skip_list: skip_list, ext: ext]}, rest}} ->
        {:ok, {new(ledger_version, previous_ledger_hash, scp_value, tx_set_result_hash, bucket_list_hash, ledger_seq, total_coins, fee_pool, inflation_seq, id_pool, base_fee, base_reserve, max_tx_set_size, skip_list, ext), rest}}
      error -> error
    end
  end

  @impl true
  def decode_xdr!(bytes, struct \\ @struct_spec)

  def decode_xdr!(bytes, struct) do
    {%XDR.Struct{components: [ledger_version: ledger_version, previous_ledger_hash: previous_ledger_hash, scp_value: scp_value, tx_set_result_hash: tx_set_result_hash, bucket_list_hash: bucket_list_hash, ledger_seq: ledger_seq, total_coins: total_coins, fee_pool: fee_pool, inflation_seq: inflation_seq, id_pool: id_pool, base_fee: base_fee, base_reserve: base_reserve, max_tx_set_size: max_tx_set_size, skip_list: skip_list, ext: ext]}, rest} =
      XDR.Struct.decode_xdr!(bytes, struct)
    {new(ledger_version, previous_ledger_hash, scp_value, tx_set_result_hash, bucket_list_hash, ledger_seq, total_coins, fee_pool, inflation_seq, id_pool, base_fee, base_reserve, max_tx_set_size, skip_list, ext), rest}
  end
end
